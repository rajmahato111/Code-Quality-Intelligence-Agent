"""
Vulnerability validator for comparing against known vulnerability databases.
"""

import json
import logging
from typing import List, Dict, Set, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import requests
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityDatabase:
    """Represents a vulnerability database."""
    name: str
    version: str
    last_updated: datetime
    vulnerabilities: List[Dict]


@dataclass
class VulnerabilityMatch:
    """Represents a match with a known vulnerability."""
    cve_id: Optional[str]
    cwe_id: Optional[str]
    vulnerability_type: str
    severity: str
    description: str
    confidence: float
    source_database: str


class VulnerabilityValidator:
    """Validates detected issues against known vulnerability databases."""
    
    def __init__(self, cache_dir: Optional[str] = None):
        """
        Initialize vulnerability validator.
        
        Args:
            cache_dir: Directory to cache vulnerability databases
        """
        self.cache_dir = Path(cache_dir) if cache_dir else Path.home() / ".code_quality_agent" / "vuln_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # Built-in vulnerability patterns
        self.builtin_patterns = self._load_builtin_patterns()
        
        # External databases
        self.databases = {}
    
    def _load_builtin_patterns(self) -> Dict[str, List[Dict]]:
        """Load built-in vulnerability patterns."""
        return {
            "sql_injection": [
                {
                    "cwe_id": "CWE-89",
                    "pattern": "string formatting in SQL query",
                    "severity": "high",
                    "description": "SQL injection vulnerability through string formatting",
                    "examples": ["f\"SELECT * FROM users WHERE id = {user_id}\"", "\"SELECT * FROM table WHERE col = \" + value"]
                }
            ],
            "command_injection": [
                {
                    "cwe_id": "CWE-78",
                    "pattern": "shell=True with user input",
                    "severity": "high",
                    "description": "Command injection vulnerability through subprocess with shell=True",
                    "examples": ["subprocess.run(user_input, shell=True)", "os.system(user_command)"]
                }
            ],
            "unsafe_deserialization": [
                {
                    "cwe_id": "CWE-502",
                    "pattern": "pickle.loads with untrusted data",
                    "severity": "critical",
                    "description": "Unsafe deserialization can lead to arbitrary code execution",
                    "examples": ["pickle.loads(user_data)", "pickle.load(untrusted_file)"]
                }
            ],
            "hardcoded_credentials": [
                {
                    "cwe_id": "CWE-798",
                    "pattern": "hardcoded password or API key",
                    "severity": "high",
                    "description": "Hardcoded credentials in source code",
                    "examples": ["password = 'admin123'", "api_key = 'sk-1234567890'"]
                }
            ],
            "xss_vulnerability": [
                {
                    "cwe_id": "CWE-79",
                    "pattern": "unescaped user input in HTML",
                    "severity": "medium",
                    "description": "Cross-site scripting vulnerability",
                    "examples": ["innerHTML = user_input", "document.write(user_data)"]
                }
            ],
            "path_traversal": [
                {
                    "cwe_id": "CWE-22",
                    "pattern": "unvalidated file path",
                    "severity": "medium",
                    "description": "Path traversal vulnerability",
                    "examples": ["open(user_filename)", "os.path.join('/uploads/', filename)"]
                }
            ],
            "weak_cryptography": [
                {
                    "cwe_id": "CWE-327",
                    "pattern": "weak hash function",
                    "severity": "medium",
                    "description": "Use of cryptographically weak hash function",
                    "examples": ["hashlib.md5()", "hashlib.sha1()"]
                }
            ],
            "eval_injection": [
                {
                    "cwe_id": "CWE-95",
                    "pattern": "eval with user input",
                    "severity": "critical",
                    "description": "Code injection through eval function",
                    "examples": ["eval(user_input)", "exec(user_code)"]
                }
            ]
        }
    
    def validate_against_vulnerabilities(self, detected_issues: List[Dict]) -> List[VulnerabilityMatch]:
        """
        Validate detected issues against known vulnerability patterns.
        
        Args:
            detected_issues: List of issues detected by the analyzer
            
        Returns:
            List of vulnerability matches
        """
        matches = []
        
        for issue in detected_issues:
            # Check against built-in patterns
            builtin_matches = self._check_builtin_patterns(issue)
            matches.extend(builtin_matches)
            
            # Check against external databases if available
            external_matches = self._check_external_databases(issue)
            matches.extend(external_matches)
        
        return matches
    
    def _check_builtin_patterns(self, issue: Dict) -> List[VulnerabilityMatch]:
        """Check issue against built-in vulnerability patterns."""
        matches = []
        
        issue_type = issue.get('type', '').lower()
        issue_description = issue.get('description', '').lower()
        issue_category = issue.get('category', '').lower()
        
        for vuln_type, patterns in self.builtin_patterns.items():
            for pattern in patterns:
                confidence = self._calculate_pattern_confidence(issue, pattern, vuln_type)
                
                if confidence > 0.5:  # Threshold for considering a match
                    matches.append(VulnerabilityMatch(
                        cve_id=None,
                        cwe_id=pattern.get('cwe_id'),
                        vulnerability_type=vuln_type,
                        severity=pattern.get('severity', 'medium'),
                        description=pattern.get('description', ''),
                        confidence=confidence,
                        source_database='builtin'
                    ))
        
        return matches
    
    def _calculate_pattern_confidence(self, issue: Dict, pattern: Dict, vuln_type: str) -> float:
        """Calculate confidence that an issue matches a vulnerability pattern."""
        confidence = 0.0
        
        issue_type = issue.get('type', '').lower()
        issue_description = issue.get('description', '').lower()
        issue_category = issue.get('category', '').lower()
        
        # Direct type match
        if vuln_type in issue_type or issue_type in vuln_type:
            confidence += 0.4
        
        # Category match
        if issue_category == 'security':
            confidence += 0.2
        
        # Description keyword matching
        pattern_keywords = pattern.get('pattern', '').lower().split()
        description_words = issue_description.split()
        
        keyword_matches = sum(1 for keyword in pattern_keywords if keyword in description_words)
        if pattern_keywords:
            confidence += (keyword_matches / len(pattern_keywords)) * 0.3
        
        # Severity alignment
        issue_severity = issue.get('severity', '').lower()
        pattern_severity = pattern.get('severity', '').lower()
        
        if issue_severity == pattern_severity:
            confidence += 0.1
        
        return min(confidence, 1.0)
    
    def _check_external_databases(self, issue: Dict) -> List[VulnerabilityMatch]:
        """Check issue against external vulnerability databases."""
        matches = []
        
        # For now, return empty list as external databases would require API keys
        # In a real implementation, this would check against:
        # - National Vulnerability Database (NVD)
        # - CVE database
        # - OWASP Top 10
        # - Language-specific vulnerability databases
        
        return matches
    
    def load_cve_database(self, cve_file: str) -> VulnerabilityDatabase:
        """
        Load CVE database from file.
        
        Args:
            cve_file: Path to CVE JSON file
            
        Returns:
            VulnerabilityDatabase object
        """
        try:
            with open(cve_file, 'r') as f:
                data = json.load(f)
            
            return VulnerabilityDatabase(
                name="CVE Database",
                version=data.get('version', 'unknown'),
                last_updated=datetime.now(),
                vulnerabilities=data.get('vulnerabilities', [])
            )
        except Exception as e:
            logger.error(f"Failed to load CVE database: {e}")
            return VulnerabilityDatabase(
                name="CVE Database",
                version="unknown",
                last_updated=datetime.now(),
                vulnerabilities=[]
            )
    
    def load_cwe_database(self, cwe_file: str) -> VulnerabilityDatabase:
        """
        Load CWE database from file.
        
        Args:
            cwe_file: Path to CWE JSON file
            
        Returns:
            VulnerabilityDatabase object
        """
        try:
            with open(cwe_file, 'r') as f:
                data = json.load(f)
            
            return VulnerabilityDatabase(
                name="CWE Database",
                version=data.get('version', 'unknown'),
                last_updated=datetime.now(),
                vulnerabilities=data.get('weaknesses', [])
            )
        except Exception as e:
            logger.error(f"Failed to load CWE database: {e}")
            return VulnerabilityDatabase(
                name="CWE Database",
                version="unknown",
                last_updated=datetime.now(),
                vulnerabilities=[]
            )
    
    def generate_vulnerability_report(self, matches: List[VulnerabilityMatch]) -> str:
        """Generate a vulnerability validation report."""
        report = []
        report.append("=== VULNERABILITY VALIDATION REPORT ===")
        report.append("")
        
        if not matches:
            report.append("No vulnerability matches found.")
            return "\n".join(report)
        
        # Group by vulnerability type
        by_type = {}
        for match in matches:
            vuln_type = match.vulnerability_type
            if vuln_type not in by_type:
                by_type[vuln_type] = []
            by_type[vuln_type].append(match)
        
        report.append(f"Total vulnerability matches: {len(matches)}")
        report.append("")
        
        # Summary by type
        report.append("Matches by Type:")
        for vuln_type, type_matches in by_type.items():
            report.append(f"  {vuln_type}: {len(type_matches)} matches")
        report.append("")
        
        # Detailed matches
        report.append("Detailed Matches:")
        for vuln_type, type_matches in by_type.items():
            report.append(f"\n{vuln_type.upper()}:")
            for match in type_matches:
                report.append(f"  - CWE: {match.cwe_id or 'N/A'}")
                report.append(f"    CVE: {match.cve_id or 'N/A'}")
                report.append(f"    Severity: {match.severity}")
                report.append(f"    Confidence: {match.confidence:.3f}")
                report.append(f"    Description: {match.description}")
                report.append(f"    Source: {match.source_database}")
                report.append("")
        
        return "\n".join(report)
    
    def get_vulnerability_statistics(self, matches: List[VulnerabilityMatch]) -> Dict[str, int]:
        """Get statistics about vulnerability matches."""
        stats = {
            'total_matches': len(matches),
            'by_severity': {},
            'by_type': {},
            'by_source': {},
            'with_cve': 0,
            'with_cwe': 0
        }
        
        for match in matches:
            # Count by severity
            severity = match.severity
            stats['by_severity'][severity] = stats['by_severity'].get(severity, 0) + 1
            
            # Count by type
            vuln_type = match.vulnerability_type
            stats['by_type'][vuln_type] = stats['by_type'].get(vuln_type, 0) + 1
            
            # Count by source
            source = match.source_database
            stats['by_source'][source] = stats['by_source'].get(source, 0) + 1
            
            # Count CVE/CWE coverage
            if match.cve_id:
                stats['with_cve'] += 1
            if match.cwe_id:
                stats['with_cwe'] += 1
        
        return stats